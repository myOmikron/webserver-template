//! Middlewares are defined in this module

pub mod auth_required;
pub mod role_required;

/// Very simple macro which produces the boilerplate required to implement a layer (middleware) for axum.
///
/// The generated boilerplate doesn't try to be very general, but uses an opinionated implementation
/// which should be simple and general enough to use.
///
/// # Usage
/// 1. Write a struct containing your middleware's data
///     - Make it `Clone`, make it cheap because it will be cloned for every handled request
///     - Add a function `async fn call(self, req: Request) -> ControlFlow<Response, Request>`
///
///       It will be called for every request.
/// 2. Invoke `impl_axum_layer!(MyMiddlewareLayer => MyMiddlewareService);`
///     - `MyMiddlewareLayer` is your middleware struct from 1.
///     - `MyMiddlewareService` is another struct generated by this macro to store services wrapped in your layer
///     - `...Layer` and `...Service` are recommended naming conventions
/// 3. Profit
///
/// # Example
///
/// ```rust
/// use std::ops::ControlFlow;
/// use tracing::info;
/// use axum::extract::Request;
/// use axum::response::Response;
/// use axum::routing::Router;
///
/// #[derive(Copy, Clone)]
/// struct MyMiddlewareLayer {
///     world: &'static str,
/// }
/// impl_axum_layer!(MyMiddlewareLayer => MyMiddlewareService);
/// impl MyMiddlewareLayer {
///     async fn call(self, req: Request) -> ControlFlow<Response, Request> {
///         info!("Hello {} from my middleware", self.world);
///         ControlFlow::Continue(req)
///     }
/// }
///
/// Router::new().layer(MyMiddlewareLayer { world: "World" });
/// ```
#[macro_export]
macro_rules! impl_axum_layer {
    (
        $Layer:ident => $Service:ident
    ) => {
        impl<S> ::tower::Layer<S> for $Layer {
            type Service = $Service<S>;
            fn layer(&self, inner: S) -> Self::Service {
                $Service {
                    layer: self.clone(),
                    inner,
                }
            }
        }

        #[doc(hidden)]
        #[derive(Clone)]
        pub struct $Service<S> {
            layer: $Layer,
            inner: S,
        }

        impl<S> ::tower::Service<::axum::extract::Request> for $Service<S>
        where
            S: ::tower::Service<::axum::extract::Request, Error = ::std::convert::Infallible>
                + Clone
                + Send
                + 'static,
            S::Response: ::axum::response::IntoResponse,
            S::Future: Send + 'static,
        {
            type Response = ::axum::response::Response;
            type Error = ::std::convert::Infallible;
            type Future = ::futures::future::BoxFuture<'static, Result<Response, Infallible>>;

            fn poll_ready(
                &mut self,
                cx: &mut ::std::task::Context<'_>,
            ) -> Poll<::std::result::Result<(), Self::Error>> {
                self.inner.poll_ready(cx)
            }

            fn call(&mut self, request: Request) -> Self::Future {
                let not_ready_inner = self.inner.clone();
                let mut ready_inner = std::mem::replace(&mut self.inner, not_ready_inner);
                let layer = self.layer.clone();

                ::std::boxed::Box::pin(async move {
                    match layer.call(request).await {
                        ::std::ops::ControlFlow::Break(response) => Ok(response),
                        ::std::ops::ControlFlow::Continue(request) => ready_inner
                            .call(request)
                            .await
                            .map(::axum::response::IntoResponse::into_response),
                    }
                })
            }
        }
    };
}
